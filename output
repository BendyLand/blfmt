   Compiling blfmt v0.1.0 (/home/ben-landrette/code/finished-projects/bendyland/blfmt)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.79s
     Running `target/debug/blfmt test.c`
[src/utils.rs:434:25] &line = "\tresult->tasks = (Task**)malloc(capacity * sizeof(Task*));"
[src/utils.rs:424:25] &line = "\tif (todo && (* todo)) {"
[src/utils.rs:424:25] &line = "\t\tif ((* todo)->tasks) {"
[src/utils.rs:424:25] &line = "\t\t\tfor (size_t i = 0; i < (* todo)->size; i++) {"
[src/utils.rs:424:25] &line = "\t\t\tfree((* todo)->tasks);"
[src/utils.rs:424:25] &line = "\t\t\t(* todo)->tasks = NULL;"
[src/utils.rs:424:25] &line = "\t\tfree(* todo);"
[src/utils.rs:424:25] &line = "\t\t(* todo) = NULL;"
[src/utils.rs:434:25] &line = "\t\ttodo->capacity = todo->capacity > 0 ? todo->capacity * 2 : 1;"
[src/utils.rs:424:25] &line = "\twhile (* line_start) {"
[src/utils.rs:424:25] &line = "\t\t\t* comma = '\\0';"
[src/utils.rs:474:5] &parts = [
    "",
    "#include <stdbool.h>",
    "#include <stdio.h>",
    "#include <string.h>",
    "#include \"todo.h\"",
    "",
    "TodoList* todo_new(size_t capacity)",
    "{",
    "\tTodoList* result = (TodoList*)malloc(sizeof(TodoList));",
    "\tresult->size = 0;",
    "\tresult->capacity = capacity > 0 ? capacity : 1;",
    "\tresult->tasks = (Task**)malloc(capacity * sizeof(Task*));",
    "\treturn result;",
    "}",
    "",
    "size_t todo_free(TodoList** todo)",
    "{",
    "\tif (todo && (*todo)) {",
    "\t\tif ((*todo)->tasks) {",
    "\t\t\tfor (size_t i = 0; i < (*todo)->size; i++) {",
    "\t\t\t\tif ((*todo)->tasks[i]) {",
    "\t\t\t\t\ttask_free(&(*todo)->tasks[i]);",
    "\t\t\t\t}",
    "\t\t\t}",
    "\t\t\tfree((*todo)->tasks);",
    "\t\t\t(*todo)->tasks = NULL;",
    "\t\t}",
    "\t\tfree(*todo);",
    "\t\t(*todo) = NULL;",
    "\t\treturn 0;",
    "\t}",
    "\treturn 1;",
    "}",
    "",
    "void todo_append(TodoList* todo, Task* task)",
    "{",
    "\tif ((todo->size + 1) >= todo->capacity) {",
    "\t\ttodo->capacity = todo->capacity > 0 ? todo->capacity * 2 : 1;",
    "\t\tTask** temp = realloc(todo->tasks, (todo->capacity * sizeof(Task*)));",
    "\t\tif (temp == NULL) {",
    "\t\t\tfprintf(stderr, \"Unable to reallocate memory for todo list.\\nElement not appended.\\n\");",
    "\t\t\treturn;",
    "\t\t}",
    "\t\ttodo->tasks = temp;",
    "\t}",
    "\ttodo->tasks[todo->size++] = task;",
    "}",
    "",
    "void todo_print(TodoList* todo)",
    "{",
    "\tprintf(\"Size: %zu\\nCapacity: %zu\\nElements:\\n\", todo->size, todo->capacity);",
    "\tfor (size_t i = 0; i < todo->size; i++) {",
    "\t\ttask_print(todo->tasks[i]);",
    "\t}",
    "}",
    "",
    "void todo_remove(TodoList* todo, Flag f, size_t id)",
    "{",
    "\tbool shift = false;",
    "\tsize_t largest = get_last_task_id(todo);",
    "\tif (id > largest || id < 1) {",
    "\t\tfprintf(stderr, \"Invalid task id.\\n\");",
    "\t\treturn;",
    "\t}",
    "\tfor (size_t i = 0; i < todo->size - 1; i++) {",
    "\t\tsize_t current_id = todo->tasks[i]->id;",
    "\t\tif (current_id == id) shift = true;",
    "\t\telse if (current_id > id && shift == false) {",
    "\t\t\tfprintf(stderr, \"Invalid task id.\\n\");",
    "\t\t\treturn;",
    "\t\t}",
    "\t\tif (shift) {",
    "\t\t\tif (current_id == id) task_free(&todo->tasks[i]);",
    "\t\t\ttodo->tasks[i] = todo->tasks[i+1];",
    "\t\t}",
    "\t}",
    "\tif (id == largest) task_free(&todo->tasks[todo->size-1]);",
    "\ttodo->size--;",
    "\ttodo_fix_ids(todo);",
    "}",
    "",
    "char* todo_to_csv(const TodoList* todo)",
    "{",
    "\tif (!todo) {",
    "\t\tfprintf(stderr, \"Don't call this on NULL.\\n\");",
    "\t\texit(1);",
    "\t}",
    "\tif (todo->size == 0) {",
    "\t\tchar* result = (char*)malloc(1);",
    "\t\tresult[0] = '\\0';",
    "\t\treturn result;",
    "\t}",
    "\t// Calculate total buffer size",
    "\tsize_t buffer_size = 0;",
    "\tfor (size_t i = 0; i < todo->size; i++) {",
    "\t\tTask* task = todo->tasks[i];",
    "\t\tif (task) {",
    "\t\t\t// id: up to 20 chars (for size_t), data: strlen chars, newline: 1 char",
    "\t\t\tbuffer_size = 20 + 1 + strlen(task->data) + 1;",
    "\t\t}",
    "\t}",
    "\t// Add space for the final null terminator",
    "\tbuffer_size = 1;",
    "\tchar* result = (char*)malloc(buffer_size);",
    "\tif (!result) {",
    "\t\tfprintf(stderr, \"Unable to allocate memory for csv output.\\n\");",
    "\t\texit(1);",
    "\t}",
    "\tresult[0] = '\\0';",
    "\t// Start with empty string",
    "\tfor (size_t i = 0; i < todo->size; i++) {",
    "\t\tTask* task = todo->tasks[i];",
    "\t\tif (task) {",
    "\t\t\tchar line[1024];",
    "\t\t\t// Temporary line buffer",
    "\t\t\tsnprintf(line, sizeof(line), \"%zu,%s\\n\", task->id, task->data);",
    "\t\t\tstrncat(result, line, buffer_size - strlen(result) - 1);",
    "\t\t}",
    "\t}",
    "\treturn result;",
    "}",
    "",
    "TodoList* csv_to_todo(const char* csv)",
    "{",
    "\tif (!csv) {",
    "\t\tfprintf(stderr, \"Don't call this on NULL.\\n\");",
    "\t\texit(1);",
    "\t}",
    "\tTodoList* todo = todo_new(0);",
    "\tconst char* line_start = csv;",
    "\twhile (*line_start) {",
    "\t\tconst char* line_end = strchr(line_start, '\\n');",
    "\t\tsize_t line_len = line_end ? (size_t)(line_end - line_start) : strlen(line_start);",
    "\t\tchar* line = (char*)malloc(line_len + 1);",
    "\t\tif (!line) {",
    "\t\t\tfprintf(stderr, \"Memory allocation failed.\\n\");",
    "\t\t\texit(1);",
    "\t\t}",
    "\t\tstrncpy(line, line_start, line_len);",
    "\t\tline[line_len] = '\\0';",
    "\t\tchar* comma = strchr(line, ',');",
    "\t\tif (comma) {",
    "\t\t\t*comma = '\\0';",
    "\t\t\tsize_t id = (size_t)strtoull(line, NULL, 10);",
    "\t\t\tconst char* data = comma + 1;",
    "\t\t\tTask* task = task_new(id, data);",
    "\t\t\ttodo_append(todo, task);",
    "\t\t}",
    "\t\tfree(line);",
    "\t\tif (!line_end) break;",
    "\t\tline_start = line_end + 1;",
    "\t}",
    "\treturn todo;",
    "}",
    "",
    "void todo_fix_ids(TodoList* todo)",
    "{",
    "\tfor (size_t i = 0; i < todo->size; i++) {",
    "\t\ttodo->tasks[i]->id = i + 1;",
    "\t}",
    "}",
    "",
    "size_t get_last_task_id(TodoList* todo)",
    "{",
    "\tif (todo->size == 0) return 1;",
    "\treturn todo->tasks[todo->size-1]->id;",
    "}",
    "",
    "size_t get_next_task_id(TodoList* todo)",
    "{",
    "\tif (todo->size == 0) return 1;",
    "\treturn todo->tasks[todo->size-1]->id + 1;",
    "}",
    "",
    "void test_todo_functions()",
    "{",
    "\tTodoList* test = todo_new(0);",
    "\tTask* one = task_new(1, \"this is a test\");",
    "\tTask* two = task_new(2, \"that was a test\");",
    "\tTask* three = task_new(3, \"here is another\");",
    "\ttodo_append(test, one);",
    "\ttodo_append(test, two);",
    "\ttodo_append(test, three);",
    "\ttodo_print(test);",
    "\ttodo_free(&test);",
    "}",
]
