Finished comment:
// /* bone.c -- The Bone Lisp interpreter.

Finished comment:
//  * Copyright (C) 2016 Wolfgang Jaehrling

Finished comment:
//  *

Finished comment:
//  * Permission to use, copy, modify, and/or distribute this software for any

Finished comment:
//  * purpose with or without fee is hereby granted, provided that the above

Finished comment:
//  * copyright notice and this permission notice appear in all copies.

Finished comment:
//  *

Finished comment:
//  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

Finished comment:
//  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

Finished comment:
//  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

Finished comment:
//  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

Finished comment:
//  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

Finished comment:
//  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

Finished comment:
//  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Finished comment:
//  */

Finished includes:
#include <assert.h>

Finished includes:
#include <inttypes.h>

Finished includes:
#include <math.h>

Finished includes:
#include <stdarg.h>

Finished includes:
#include <stdbool.h>

Finished includes:
#include <stdint.h>

Finished includes:
#include <stdio.h>

Finished includes:
#include <stdlib.h>

Finished includes:
#include <string.h>

Finished includes:
#include <sys/mman.h>

Finished includes:
#include <unistd.h>

Finished includes:
#include "bone.h"

Finished declaration:
static any last_value;

Finished comment:
// FIXME: thread-local

Finished declaration:
static bool silence_errors = false;

Finished comment:
// FIXME: thread-local?

Finished identifier: va_start

Finished argument list: (args, fmt)

Finished identifier: vfprintf

Finished argument list: (stderr, fmt, args)

Finished identifier: va_end

Finished argument list: (args)

Finished comment:
//static void eprint(any); static any L(any x) { eprint(x); puts(""); return x; } // for debugging

Finished identifier: eprintf

Finished argument list: ("%s\n", msg)

Finished identifier: exit

Finished argument list: (1)

Finished identifier: abort

Finished argument list: ()

Compound statement:
{
	case t_cons:
	return "cons";
	
	case t_sym:
	return "sym";
	
	case t_str:
	return "str";
	
	case t_sub:
	return "sub";
	
	case t_num:
	return "num";
	
	case t_other:
	
	default:
		abort();
	
	// never called with t_other
}
Finished declaration:
static void eprint(any x);

Finished declaration:
static void backtrace();

Finished identifier: eprintf

Finished argument list: ("ERR: ")

Finished identifier: va_start

Finished argument list: (args, fmt)

Finished identifier: vfprintf

Finished argument list: (stderr, fmt, args)

Finished identifier: va_end

Finished argument list: (args)

Finished identifier: eprintf

Finished argument list: ("\n")

Finished identifier: backtrace

Finished argument list: ()

Finished identifier: throw

Finished argument list: ()

Finished identifier: eprintf

Finished argument list: ("ERR: %s: ", msg)

Finished identifier: eprint

Finished argument list: (x)

Finished identifier: eprintf

Finished argument list: ("\n")

Finished identifier: backtrace

Finished argument list: ()

Finished identifier: throw

Finished argument list: ()

Finished identifier: eprintf

Finished argument list: ("ERR: typecheck failed: (%s? ", type_name(t))

Finished identifier: eprint

Finished argument list: (x)

Finished identifier: eprintf

Finished argument list: (")\n")

Finished identifier: backtrace

Finished argument list: ()

Finished identifier: throw

Finished argument list: ()

expression_statement: type_error(x, t);

Finished identifier: check

Finished argument list: (x, t)

Finished identifier: check

Finished argument list: (x, t_num)

expression_statement: generic_error("ERR: expected integer type", x);

expression_statement: basic_error("ERR: integer out of allowed range: %" PRId64, n);

expression_statement: generic_error("ERR: expected float type", x);

Finished identifier: abort

Finished argument list: ()

Compound statement:
{
	case t_num_int:
	return (float)any2int(x);
	
	case t_num_float:
	return any2float(x);
	
	default:
		abort();
	
}
Finished comment:
//////////////// regions ////////////////

Finished declaration:
static size_t blocksize;

Finished comment:
// in bytes

Finished declaration:
static size_t blockwords;

Finished comment:
// words per block

Finished declaration:
static any blockmask;

Finished comment:
// to get the block an `any` belongs to; is not actually an object!

Finished declaration:
static any **free_block;

Finished comment:
// A block begins with a pointer to the previous block that belongs to the region.

Finished comment:
// The metadata of a region (i.e. this struct) is stored in its first block.

Finished comment:
// This code is in FORTH-style.

Finished comment:
// get ptr to start of block that x belongs to.

Finished identifier: blocks_init

Finished argument list: (p, ALLOC_BLOCKS_AT_ONCE)

expression_statement: free_block = fresh_blocks();

Finished identifier: ensure_free_block

Finished argument list: ()

Finished identifier: reg_init

Finished argument list: (r, b)

return_statement: return;

Finished identifier: munmap

Finished argument list: (b, blocksize)

Finished identifier: blocks_sysfree

Finished argument list: (next)

Finished identifier: blocks_sysfree

Finished argument list: (r->current_block)

Finished declaration:
static reg permanent_reg;

Finished comment:
// FIXME: thread-local

Finished declaration:
static reg *reg_stack;

Finished declaration:
static int reg_pos, reg_allocated;

Finished declaration:
static any **allocp, **current_block;

Finished comment:
// from currently used reg.

Finished identifier: store_reg

Finished argument list: (curr_reg)

Finished identifier: inc_regs

Finished argument list: ()

Finished identifier: load_reg

Finished argument list: (curr_reg)

Finished identifier: store_reg

Finished argument list: (curr_reg)

Finished identifier: load_reg

Finished argument list: (curr_reg)

Finished identifier: reg_push

Finished argument list: (permanent_reg)

Finished identifier: reg_push

Finished argument list: (reg_new())

Finished identifier: reg_free

Finished argument list: (reg_pop())

return_statement: return res;

Finished declaration:
static any copy(any x);

Finished identifier: reg_push

Finished argument list: (reg_stack[reg_pos-1])

Finished identifier: reg_pop

Finished argument list: ()

Finished comment:
//////////////// exceptions ////////////////

Finished comment:
// FIXME: thread-local

Finished declaration:
static struct exc_buf {
  jmp_buf buf;
  int reg_pos;
} *exc_bufs;

Finished declaration:
static int exc_num;

Finished declaration:
static int exc_allocated;

expression_statement: fail("internal error: throw/catch mismatch");

Finished identifier: exc_buf_nonempty

Finished argument list: ()

Finished identifier: rollback_reg_sp

Finished argument list: (exc_bufs[exc_num].reg_pos)

Finished identifier: exc_buf_nonempty

Finished argument list: ()

Finished comment:
//////////////// conses / lists ////////////////

Finished comment:
// no tag() needed as t_cons==0

Finished comment:
// fast, no typecheck

Finished comment:
// likewise

Finished identifier: check

Finished argument list: (x, t_cons)

Finished identifier: check

Finished argument list: (x, t_cons)

Finished identifier: reg_permanent

Finished argument list: ()

Finished identifier: reg_pop

Finished argument list: ()

Finished identifier: reg_permanent

Finished argument list: ()

Finished identifier: reg_pop

Finished argument list: ()

expression_statement: lg->xs = lg->last = single(x);

Finished identifier: set_fdr

Finished argument list: (lg->last, new)

Else clause inner compound statement:
{
	any new = single(x);
	set_fdr(lg->last, new);
	lg->last = new;
}

Finished identifier: foreach

Finished argument list: (x, xs)

Finished identifier: listgen_add

Finished argument list: (lg, x)

expression_statement: lg->xs = lg->last = x;

Finished identifier: set_fdr

Finished argument list: (lg->last, x)

Else clause expression statement: set_fdr(lg->last, x);

Finished identifier: listgen_add_list

Finished argument list: (&lg, xs)

Finished identifier: foreach

Finished argument list: (x, xs)

return_statement: return true;

Finished identifier: foreach

Finished argument list: (x, xs)

return_statement: return fdr(x);

Finished identifier: foreach

Finished argument list: (x, xs)

return_statement: return x;

return_statement: return b;

Finished identifier: foreach

Finished argument list: (x, a)

Finished identifier: listgen_add

Finished argument list: (&lg, x)

Finished identifier: listgen_set_tail

Finished argument list: (&lg, b)

return_statement: return far(xs);

Finished identifier: foreach_cons

Finished argument list: (pair, xs)

Finished identifier: set_fdr

Finished argument list: (pair, far(fdr(pair)))

return_statement: return NIL;

expression_statement: from_p = false;

expression_statement: from_p = true;

Finished identifier: call2

Finished argument list: (bigger_p, far(p), far(q))

Else clause inner compound statement:
{
	call2(bigger_p, far(p), far(q));
	from_p = !is(last_value);
}

Else if: else if (len_of_q == 0 ||)


Else clause inner compound statement:
{
	len_of_q--;
	e = q;
	q = fdr(q);
}

expression_statement: set_fdr(tl, e);

Else clause expression statement: hd = e;

Finished identifier: set_fdr

Finished argument list: (tl, NIL)

return_statement: return hd;

Finished identifier: abort

Finished argument list: ()

Compound statement:
{
	case t_num_int:
	return any2int(x) == 0;
	
	case t_num_float:
	return any2float(x) == 0.0;
	
	default:
		abort();
	
}
Finished comment:
//////////////// strs ////////////////

Finished comment:
// FIXME: for short strings only

ERROR
Handling ERROR:
name: {
text: {

