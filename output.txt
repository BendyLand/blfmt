Finished includes: #include <string.h>

Finished includes: #include "example_header.h" // stdio.h, stdlib.h, string.h, stdbool.h

Finished includes: #include <stdio.h>

Finished includes: #include <stdlib.h>

Finished includes: #include <stdbool.h>

Finished declaration: void strAppend(string* original, const char* suffix);

Finished declaration: string** strSplit(string* original, const char delim);

function_definition
primitive_type: size_t
function_declarator: strArrLen(string** strArr)
Handle open brace...
Finished declaration: size_t result = 0;

while_statement
while: while
parenthesized_expression: (strArr[result] != NULL)
expression_statement: result++;

Finished return: return result;

Handle closing brace...


function_definition
identifier: string
pointer_declarator: * strArrJoin(string** arr, const char* delim)
Handle open brace...
Finished declaration: size_t len = 0;

while_statement
while: while
parenthesized_expression: (arr[len] != NULL)
expression_statement: len++;

Finished declaration: string* result = str("");

for_statement
for: for
(: (
declaration: size_t i = 0;
binary_expression: i < len
;: ;
update_expression: i ++
): )
Handle open brace...
expression_statement
call_expression: strAppend(result, arr[i]->data)
;: ;

expression_statement
call_expression: strAppend(result, delim)
;: ;

Handle closing brace...


Finished return: return result;

Handle closing brace...


Finished comment:
/*
This is a test
of having a block comment
*/
function_definition
primitive_type: void
function_declarator: strAppend(string* original, const char* suffix)
Handle open brace...
Finished declaration: size_t newLen = original->length + strlen(suffix) + 1;

Finished declaration: char* newData = (char*)realloc(original->data, newLen);

if_statement
if: if
parenthesized_expression: (!newData)
Handle open brace...
expression_statement
call_expression: perror("Failed to reallocate memory for new string.")
;: ;

expression_statement
call_expression: exit(EXIT_FAILURE)
;: ;

Handle closing brace...


expression_statement
call_expression: strcat(newData, suffix)
;: ;

expression_statement
;: ;

expression_statement
;: ;

Handle closing brace...


Finished comment:
/* This is another,
slightly harder test */
function_definition
identifier: string
pointer_declarator: ** strSplit(string* original, const char delim)
Handle open brace...
Finished declaration: string** result;

Finished declaration: size_t len = 0;

for_statement
for: for
(: (
declaration: size_t i = 0;
binary_expression: i < original->length
;: ;
update_expression: i++
): )
Handle open brace...
if_statement
if: if
parenthesized_expression: (original->data[i] == delim)
Handle open brace...
expression_statement
;: ;

Handle closing brace...


Handle closing brace...


expression_statement
;: ;

Finished declaration: size_t n = 0;

Finished declaration: char* c = (char*)malloc(2);

expression_statement
;: ;

Finished declaration: string* temp = str("");

Finished comment:
/*
    And this is a block comment inside a function!
    */
for_statement
for: for
(: (
declaration: size_t i = 0;
binary_expression: i < original->length
;: ;
update_expression: i++
): )
Handle open brace...
if_statement
if: if
parenthesized_expression: (original->data[i] == delim)
Handle open brace...
Finished declaration: string* template = strCopy(temp);

expression_statement
;: ;

expression_statement
call_expression: strClear(temp)
;: ;

expression_statement
;: ;

continue_statement
continue: continue
;: ;

Handle closing brace...


expression_statement
;: ;

expression_statement
call_expression: strAppend(temp, c)
;: ;

Handle closing brace...


if_statement
if: if
parenthesized_expression: (strcmp(temp->data, "") != 0)
Handle open brace...
Finished declaration: string* template = strCopy(temp);

expression_statement
;: ;

expression_statement
;: ;

Handle closing brace...


expression_statement
;: ;

expression_statement
call_expression: free(c)
;: ;

expression_statement
call_expression: strFree(temp)
;: ;

Finished return: return result;

Handle closing brace...


function_definition
primitive_type: void
function_declarator: strArrFree(string** original)
Handle open brace...
Finished declaration: const int test = 5;

if_statement
if: if
parenthesized_expression: (original)
Handle open brace...
Finished declaration: size_t i = 0;

while_statement
while: while
parenthesized_expression: (original[i] != NULL)
Handle open brace...
expression_statement
call_expression: strFree(original[i])
;: ;

expression_statement
;: ;

Handle closing brace...


expression_statement
call_expression: free(original)
;: ;

Handle closing brace...


Handle closing brace...


function_definition
identifier: string
pointer_declarator: * strCopy(string* original)
Handle open brace...
Finished return: return str(original->data);

Handle closing brace...


function_definition
identifier: string
pointer_declarator: * substr(string* original, size_t start, size_t end)
Handle open brace...
Finished declaration: size_t len = end - start;

Finished declaration: char* temp = (char*)malloc(len+1);

expression_statement
call_expression: strncpy(temp, original->data+start, len)
;: ;

expression_statement
;: ;

Finished declaration: string* result;

expression_statement
;: ;

expression_statement
call_expression: free(temp)
;: ;

Finished return: return result;

Handle closing brace...


function_definition
primitive_type: bool
function_declarator: strIsEmpty(string* str)
Handle open brace...
if_statement
if: if
parenthesized_expression: (str->length == 0 || strlen(str->data) < 1)
Handle open brace...
Finished return: return true;

Handle closing brace...

else_clause: else
    {
        return false;
    }

Handle closing brace...


function_definition
identifier: string
pointer_declarator: * str(const char* text)
Handle open brace...
Finished declaration: string* result = (string*)malloc(sizeof(string));

if_statement
if: if
parenthesized_expression: (!result)
Handle open brace...
expression_statement
call_expression: perror("Failed to allocate memory for string\n")
;: ;

expression_statement
call_expression: exit(EXIT_FAILURE)
;: ;

Handle closing brace...


expression_statement
;: ;

expression_statement
;: ;

if_statement
if: if
parenthesized_expression: (!result->data)
Handle open brace...
expression_statement
call_expression: perror("Failed to allocate memory for string data\n")
;: ;

expression_statement
call_expression: free(result)
;: ;

expression_statement
call_expression: exit(EXIT_FAILURE)
;: ;

Handle closing brace...


expression_statement
call_expression: strcpy(result->data, text)
;: ;

Finished return: return result;

Handle closing brace...


function_definition
primitive_type: void
function_declarator: strFree(string* str)
Handle open brace...
if_statement
if: if
parenthesized_expression: (str)
Handle open brace...
expression_statement
call_expression: free(str->data)
;: ;

expression_statement
call_expression: free(str)
;: ;

Handle closing brace...

else_clause: else {
        // nothing happens
    }

Handle closing brace...


function_definition
primitive_type: void
function_declarator: strClear(string* str)
Handle open brace...
Finished declaration: char* newData = (char*)realloc(str->data, 1);

if_statement
if: if
parenthesized_expression: (!newData)
Handle open brace...
expression_statement
call_expression: perror("Failed to reallocate memory for cleared string.")
;: ;

expression_statement
call_expression: exit(EXIT_FAILURE)
;: ;

Handle closing brace...


expression_statement
;: ;

expression_statement
;: ;

expression_statement
;: ;

Handle closing brace...


